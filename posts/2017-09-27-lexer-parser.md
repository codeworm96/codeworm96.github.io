---
title: 谈 lexer & parser
tags: internship, interview, lexer, parser
---

> Growth mindset 是个好东西，但不是每家公司都有。

不知道为何自己面试时总是遇到写 lexer & parser 有关的问题...
据院长说，大部分中国大学的编译原理课程设置，大部分都是在讲文法，而忽视了
backend. 虽然我们学院的课程设置是从前到后一个完整的编译器实现，但是我还是有自信，
在 lexer & parser 知识上是没有短板的。而且 parser 作为一个已经成熟的领域，
不像系统还在发展中，理应不会有太多的不确定。

在微软的面试中，我开始想用 parser combinator 被说不太好，最后还是用了传统的编译原理方法。
这个我认为可以理解，毕竟 parser combinator 对不熟悉函数式风格的人来说确实不易理解。
但是昨天的面试中，我使用传统的 lexer & parser 技巧竟然被批判。
要不是分布式键值存储不需要编译原理，真的令人怀疑这样的编译原理水平是如何能写出 sql 的
parser 的。反正我已经心态放平，那我也不怕在这里指出交流中发现的理解上的误区。

# lexer
这里的问题是写 lexer 支持解析出浮点数，变量名，操作符。
我的做法是先写出各自的正则文法，然后转 dfa. 面试官：你这不行，我的字典树最厉害。
首先，我们可以看下 [Trie](https://en.wikipedia.org/wiki/Trie) 的定义，
根本不是干这个活的。因为没看到具体实现，不能确定，交流下来感觉大概说的是，
直接写出状态机并实现。

首先我要澄清一点，正则文法（注意某些加了扩展的正则表达式实现不算）和 dfa 是等价的，
这个证明非常容易，因为存在两者互相转换的算法，算法具体是怎样，这里不做展开，
应该任意编译原理的书都有涉及。所以用正则文法还是 dfa 表达完全是个人偏好/习惯问题。
一个人上来先写 dfa 还是正则并不是一个能区分水平的点。

面试官又说正则慢，确实如果放到运行时搞，确实要花时间。但是正则 -> nfa -> dfa -> dfa最简化，
这一套完全可以编译时完成，运行时查状态转移表即可，和 hardcode dfa 性能同级，这也是 flex
的流程。而且，直接写 dfa 你又如何保证自己的 dfa 一定是最简化的呢，不是最简化那性能还是要有疑问，
dfa简化的算法你不会还是不行。

面试官又觉得这是直接用工具水平太差，但是这些算法我都掌握，给点时间纸上也能推，有何问题？
研究完善的理论不去实践，而要另起一套显示自己的水平，我觉得反而不好。

最后面试官又觉得要回溯性能差，但这个是 lexer 必须的，与匹配方式无关。因为 lexer
必须找到 longest match，那就必须到匹配失败的地方才能判定。比如 if8, 显然 i 匹配变量名规则，
但我们还不能确定，if 匹配 if ，但我们还不能确定，if8 匹配变量名规则，但我们还不能确定，
然后我们遇到结尾匹配失败，这时我们才能确定 if8 作为一个变量名。

# parser
这里的问题是要写一个表达式计算器。我的方法是手写递归下降，而面试官坚持认为
[Shunting-yard_algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)
比这个要强。但是如果我们找一个表达式进行模拟，对比二者的执行过程会发现是殊途同归的，
Shunting-yard algorithm 多看一个判断是出栈还是入栈，递归下降多看一个，判断是调用新的规则，
还是当前规则完成返回。二者唯一的区别在于栈是自己维护还是用调用栈，性能区别可以说是微乎其微吧，
除非特别关心函数调用的开销。个人认为递归下降更容易扩展，
更好理解与实现，写这个无可非议。而 Shunting-yard algorithm 属于没有系统学习 parsering
时的权宜之计，初高中信息学竞赛玩剩下的东西，反倒不是一个好的答案。

总之，如果面试中遇到答案不唯一的问题，大家都是聪明人，有不一样的想法很正常。
如果面试官认定所谓的标准答案，对其他答案都斥之为垃圾，预设立场，甚至都不去深入的了解分析，
那么体验是非常之差的。看过我之前有关面试的文章的读者应该知道，
就算是某人类希望的面试官这样搞，我也是要批判一番的。